// function \"neg\" has type (Num -> Num)\nfunction neg(x) {\n\treturn (0.0-x);\n}\n// function \"tail\" has type ([a] -> [a])\nfunction tail(xs) {\n\treturn Array.prototype.slice.call(xs, 1.0, length(xs));\n}\n// function \"empty\" has type [Num]\nfunction empty() {\n\treturn /* [Num] */ [];\n}\n// function \"length\" has type ([a] -> Num)\nfunction length(xs) {\n\treturn (() => {\n\t\tif (equal(/* [Char] */ [], xs)) {\n\t\t\treturn 0.0;\n\t\t} \n\t\tif (T) {\n\t\t\treturn (1.0+length(Array.prototype.slice.call(xs, 0.0, neg(1.0))));\n\t\t}\n\t})();\n}\n// function \"sort\" has type ([Num] -> [Num])\nfunction sort(ns) {\n\treturn sort2(length(ns), ns);\n}\n// function \"sort2\" has type (Num -> ([Num] -> [Num]))\nfunction sort2(len, ns) {\n\treturn (() => {\n\t\tif ((len<=1.0)) {\n\t\t\treturn ns;\n\t\t} \n\t\tif (T) {\n\t\t\treturn merge(sort(Array.prototype.slice.call(ns, 0.0, (len/2.0))), sort(Array.prototype.slice.call(ns, (len/2.0), len)));\n\t\t}\n\t})();\n}\n// function \"order\" has type (Num -> (Num -> [Num]))\nfunction order(x, y) {\n\treturn (() => {\n\t\tif ((x<y)) {\n\t\t\treturn /* [Num] */ [x,y];\n\t\t} \n\t\tif (T) {\n\t\t\treturn /* [Num] */ [y,x];\n\t\t}\n\t})();\n}\n// function \"merge\" has type ([Num] -> ([Num] -> [Num]))\nfunction merge(xs, ys) {\n\treturn (() => {\n\t\tif (equal(xs, empty())) {\n\t\t\treturn ys;\n\t\t} \n\t\tif (equal(ys, empty())) {\n\t\t\treturn xs;\n\t\t} \n\t\tif (T) {\n\t\t\treturn Array.prototype.concat.call(order(Array.prototype.at.call(xs, 0.0) ?? 0.0, Array.prototype.at.call(xs, 0.0) ?? 0.0), merge(tail(xs), tail(ys)));\n\t\t}\n\t})();\n}\n