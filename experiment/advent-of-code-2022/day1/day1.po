#
parseList list =  lines list
              <&> (\str -> if str == "" then 0 else read str :: Integer)
               &  groupBy (\a b -> a > 0 && b > 0)
               &  filter (/=[0])
              <&> sum

#

list [[Char]]
list = [Char]:[ Char:['1' '2' '3'] Char:['4' '4'] ]

# CHAR UTILS #

charToNum -> Char -> Num Num
charToNum char fallback =
  ? == char '0' 0
  ? == char '1' 1
  ? == char '2' 2
  ? == char '3' 3
  ? == char '4' 4
  ? == char '5' 5
  ? == char '6' 6
  ? == char '7' 7
  ? == char '8' 8
  ? == char '9' 9
  fallback

_read -> Char -> [Num] [Num]
_read char nums = +> * (exp 10 (length nums)) (charToNum char 0) nums

read -> [Char] Num
read chars = (sum (foldr _read Num:[] (reverse chars)))

# MATH UTILS #

# https://en.wikipedia.org/wiki/Exponentiation_by_squaring #
exp -> Num -> Num Num
exp x n =
  ? < n 0 (exp / 1 x - 0 1)
  ? == n 0 1
  ? == % n 2 0 (exp * x x / n 2)
  * x (exp * x x / - n 1 2)

# LIST UTILS #

_foldl -> -> j -> k k -> k -> j -> [j] k
_foldl alg acc x xs = (alg x (foldl alg acc xs))

foldl -> -> a -> b b -> b -> [a] b
foldl alg acc xs =
  <+ xs acc (_foldl alg acc)

_foldr -> (-> j -> k k) -> k -> j -> [j] k
_foldr alg acc x xs = (foldr alg (alg x acc) xs)

foldr -> (-> a -> b b) -> b -> [a] b
foldr alg acc xs =
  <+ xs acc (_foldr alg acc)

_len -> a -> Num Num
_len x len = + 1 len

length -> [a] Num
length xs = (foldr _len 0 xs)

_rev -> a -> [a] [a]
_rev x xs = +> x xs

reverse -> [a] [a]
reverse xs = (foldr _rev a:[] xs)

add -> Num -> Num Num
add a b = + a b

sum -> [Num] Num
sum ns = (foldr add 0 ns)

not -> x -> x Atom
not a b = == False == a b

push -> [h] -> h -> [h] [h]
push ys x xs = +> x (concat xs ys)

concat -> [a] -> [a] [a]
concat xs ys =
  <+ xs ys (push ys)

curryCons -> {[a] [[a]]} [[a]]
curryCons tup = +> @1 tup @2 tup

_splitOn -> z -> z -> {[z] [[z]]} {[z] [[z]]}
_splitOn on x acc =
  ? (not x on) {+> x @1 acc @2 acc}
  {z:[] (curryCons acc)}

splitOn -> a -> [a] [[a]]
splitOn on xs = (curryCons (foldl (_splitOn on) {a:[] [a]:[]} xs))
